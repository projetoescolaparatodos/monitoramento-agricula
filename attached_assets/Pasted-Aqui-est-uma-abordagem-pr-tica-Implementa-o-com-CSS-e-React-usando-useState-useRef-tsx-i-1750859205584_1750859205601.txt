Aqui está uma abordagem prática:

Implementação com CSS e React (usando useState + useRef)
tsx
import { useState, useRef } from 'react';
import './HomeMediaGallerySection.css'; // Seu arquivo CSS existente

type MediaItem = {
  id: string;
  url: string;
  type: 'image' | 'video';
  alt?: string;
};

export function HomeMediaGallerySection({ medias }: { medias: MediaItem[] }) {
  const [currentScroll, setCurrentScroll] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  const itemRef = useRef<HTMLDivElement>(null);

  const scrollStep = 3; // Número de itens para rolar por vez
  const visibleItems = 3; // Itens visíveis simultaneamente

  const handleNext = () => {
    if (!containerRef.current || !itemRef.current) return;
    
    const itemWidth = itemRef.current.offsetWidth;
    const maxScroll = (medias.length - visibleItems) * itemWidth;
    
    setCurrentScroll(prev => {
      const newScroll = prev + (scrollStep * itemWidth);
      return Math.min(newScroll, maxScroll);
    });
  };

  const handlePrev = () => {
    if (!containerRef.current || !itemRef.current) return;
    
    const itemWidth = itemRef.current.offsetWidth;
    
    setCurrentScroll(prev => {
      const newScroll = prev - (scrollStep * itemWidth);
      return Math.max(newScroll, 0);
    });
  };

  return (
    <div className="media-gallery-container">
      <button 
        className="nav-button prev"
        onClick={handlePrev}
        disabled={currentScroll <= 0}
        aria-label="Mídias anteriores"
      >
        &lt;
      </button>

      <div className="media-scroll-wrapper">
        <div 
          ref={containerRef}
          className="media-items-container"
          style={{
            transform: `translateX(-${currentScroll}px)`,
            transition: 'transform 0.5s ease'
          }}
        >
          {medias.map((media) => (
            <div 
              key={media.id}
              ref={itemRef}
              className="media-item"
            >
              {media.type === 'image' ? (
                <img src={media.url} alt={media.alt || ''} />
              ) : (
                <video controls>
                  <source src={media.url} type="video/mp4" />
                </video>
              )}
            </div>
          ))}
        </div>
      </div>

      <button 
        className="nav-button next"
        onClick={handleNext}
        disabled={currentScroll >= (medias.length - visibleItems) * (itemRef.current?.offsetWidth || 0)}
        aria-label="Próximas mídias"
      >
        &gt;
      </button>
    </div>
  );
}
CSS Adicional (para adicionar ao seu arquivo existente):
css
.media-gallery-container {
  position: relative;
  width: 100%;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 0 40px; /* Espaço para os botões */
}

.media-scroll-wrapper {
  width: 100%;
  overflow: hidden;
}

.media-items-container {
  display: flex;
  gap: 16px;
  will-change: transform; /* Otimização de performance */
}

.media-item {
  min-width: calc(33.33% - 11px); /* 3 itens por view */
  flex-shrink: 0;
  aspect-ratio: 16/9;
  border-radius: 8px;
  overflow: hidden;
}

.media-item img, 
.media-item video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.nav-button {
  position: absolute;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  z-index: 2;
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.nav-button.prev {
  left: 0;
}

.nav-button.next {
  right: 0;
}

.nav-button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.nav-button:hover:not(:disabled) {
  background: rgba(0, 0, 0, 0.9);
}
Melhorias incluídas:
Controle preciso do scroll: Usamos transform/translateX para animação suave

Responsividade: O cálculo é baseado no tamanho real dos itens

Acessibilidade: Botões com labels ARIA

Performance: will-change para otimizar animações

Suporte a vídeos: Detecta o tipo de mídia automaticamente

Como adaptar ao seu componente existente:
Mantenha quaisquer props existentes que seu componente já recebe

Preserve os estilos específicos do seu projeto

Ajuste o visibleItems e scrollStep conforme necessário

Se já tiver lógica de clique nos itens, mantenha-a

Quer que eu adapte alguma parte específica para se encaixar melhor na sua implementação atual?